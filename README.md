# GC-instruction  gc垃圾回收机制
this mainly say how gc works

##1. what 
关于什么是垃圾回收机制，接触了Java之后就会慢慢接触，GC是Garbage Collection的简称，他主要用于回收程序中不再使用的内存。
而与C++不同的是，Java语言的gc机制可以自动的检测对象的作用域，并自动释放不再使用的内存空间，大大减轻了开发人员的操作。
不仅提高率生产效率，而且减小了开发人员因错误的操作内存而导致的程序崩溃的问题，保证了程序的稳定性。但是，垃圾回收并非是完的，
为了垃圾回收，垃圾回收器必须跟踪内存的使用情况释放没用的对象，在完成内存的释放后还要处理堆中的碎片，增加了JVM的负担，
从而降低了程序的效率！
##2. how 
gc垃圾回收机制主要负责完成3项任务：
* 分配内存
* 确保被引用的对象的内存不被错误的回收
* 回收不在被引用的对象的内存空间 

垃圾回收器会使用有向图来记录和管理内存中的所有对象，通过有向图来识别对象是否可达，
也就是是否又变量引用它，对于没有变量引用的对象，便是不可达对象，是可被垃圾回收的。
##3. 几种常见的垃圾回收算法
* **引用计数算法**：
简单低效，在堆中每个对象都有一个引用计数器，当对象被引用时，计数器加1，对象被置为bull或离开作用域时，
计数器减1，无法解决相互引用问题（JVM不予采用）
* **追踪回收算法**：
利用JVM维护的对象引用图，从根节点开始遍历对象的引用图，同时标记遍历到的对象，遍历结束后，回收没有被被标记的对象。
* **压缩回收算法**：
主要是利用堆操作，把堆中活动的对象全部移到堆中的某一端，使得堆中另一端留出大量空闲区域，大大消除了堆碎片的工作，但每次操作
会带来性能的消耗。
* **复制回收算法**：
把堆分成2个完全一样的区域，在任意时刻，只有其中一个区域被使用，直到其被消耗完，此时垃圾回收器会中断程序的执行，通过遍历的方式
把所有活动的对象复制到另一个区域中，并消除内存空间，当复制结束后程序继续运行，直到这块区域被用完，然后继续重复上述的方法。当然这种
方法效率不高，而且需要内存大。
* **按代回收算法**：
把堆分成若干个子堆，每一个子堆被视为一代，算法在运行的过程中优先收集那些“年幼”的对象，如果一个对象进过多次收集依然“存活”，
那么就把该对象转移到高一级的堆中，减少扫描次数。
#4. 主动通知JVM进行垃圾回收
Java 语言本身并未给开发人员提供显示释放已分配内存的方法，所以我们不能实时的调用垃圾回收器对对象进行垃圾回收。但是可以通过system.gc()方法来通知立即回收期运行
